{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Plutus.Model         (Run,
                                       TypedValidator (TypedValidator),
                                       adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue)
import           Plutus.Model         (Ada (Lovelace), DatumMode (HashDatum),
                                       Run, Tx, TypedValidator (TypedValidator),
                                       UserSpend, ada, adaValue, currentTimeRad,
                                       defaultBabbage, logError, mustFail,
                                       newUser, payToKey, payToScript, spend,
                                       spendScript, submitTx, testNoErrors,
                                       toV2, userSpend, utxoAt, validateIn,
                                       valueAt, waitUntil)
import           Plutus.V2.Ledger.Api (POSIXTime, PubKeyHash,
                                       TxOut (txOutValue), TxOutRef, Value)
import           PlutusTx.Prelude     (($))
import           PlutusTx.Builtins    (Integer, mkI)
import Control.Monad
import           Prelude              hiding (($), Integer)
import qualified ExploitableSwap      as OnChain
import           Test.Tasty           (defaultMain, testGroup)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending
      , bad  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

setupUsers :: Run (PubKeyHash, PubKeyHash)
setupUsers =
  (,)
    <$> newUser (ada (Lovelace 1000))
    <*> newUser (ada (Lovelace 1000))

waitBeforeConsumingTx :: POSIXTime
waitBeforeConsumingTx = 1000

-- Create transaction that spends "usp" to lock "val" in "swapScript"
lockingTx :: OnChain.DatumSwap -> UserSpend -> Value -> Tx
lockingTx dsDatum usp val =
  mconcat
    [ userSpend usp
    , payToScript swapScript (HashDatum dsDatum) val
    ]

-- Create transaction that spends "ref" to unlock "val" from the "swapScript" validator
consumingTx :: OnChain.DatumSwap -> PubKeyHash -> TxOutRef -> Value -> Tx
consumingTx dsDatum usr ref val =
  mconcat
    [ spendScript swapScript ref () dsDatum
    , payToKey usr val
    ]

doubleConsumingTx :: OnChain.DatumSwap -> PubKeyHash -> TxOutRef -> Value -> Tx
doubleConsumingTx dsDatum usr ref val =
  mconcat
    [ spendScript swapScript ref () dsDatum
    , spendScript swapScript ref () dsDatum
    , payToKey usr val
    ]

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Run ()
normalSpending = do
  -- SETUP USERS
  (u1, u2) <- setupUsers
  -- USER 1 LOCKS 100 ADA ("val") IN VALIDATOR
  let val = adaValue 100                    -- Define value to be transfered
      dsDatum = OnChain.DatumSwap u2 100
  sp <- spend u1 val                        -- Get user's UTXO that we should spend
  submitTx u1 $ lockingTx dsDatum sp val          -- User 1 submits "lockingTx" transaction
  -- WAIT FOR A BIT
  waitUntil waitBeforeConsumingTx
  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                -- Query blockchain to get all UTxOs at script
  let [(ref, out)] = utxos                  -- We know there is only one UTXO (the one we created before)
  ct <- currentTimeRad 100                  -- Create time interval with equal radius around current time
  tx <- validateIn ct $ consumingTx dsDatum u2 ref (txOutValue out)  -- Build Tx
  submitTx u2 tx                            -- User 2 submits "consumingTx" transaction
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  unless (v1 == adaValue 900 && v2 == adaValue 1_100) $  -- Check if final balances match expected balances
    logError "Final balances are incorrect"


doubleSpending :: Run ()
doubleSpending = do
  -- SETUP USERS
  (u1, u2) <- setupUsers
  -- USER 1 LOCKS 100 ADA ("val") IN VALIDATOR
  let val = adaValue 100                    -- Define value to be transfered
      dsDatum = OnChain.DatumSwap u2 100
  sp <- spend u1 val                        -- Get user's UTXO that we should spend
  submitTx u1 $ lockingTx dsDatum sp val          -- User 1 submits "lockingTx" transaction
  -- WAIT FOR A BIT
  waitUntil waitBeforeConsumingTx
  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                -- Query blockchain to get all UTxOs at script
  let [(ref, out)] = utxos                  -- We know there is only one UTXO (the one we created before)
  ct <- currentTimeRad 100                  -- Create time interval with equal radius around current time
  tx <- validateIn ct $ doubleConsumingTx dsDatum u2 ref (txOutValue out)  -- Build Tx
  submitTx u2 tx                            -- User 2 submits "consumingTx" transaction
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  unless (v1 == adaValue 900 && v2 == adaValue 1_100) $  -- Check if final balances match expected balances
    logError "Final balances are incorrect"
