{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}

module ExploitableSwap where

import           Plutus.V2.Ledger.Api      (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton)
import           Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo(..))
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Builtins         (BuiltinData, Integer)
import           PlutusTx.Prelude          (Bool (..), (==), traceIfFalse, (&&), length)
import           Utilities                 (wrapValidator)

---------------------------------------------------------------------------------------------------
----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  }
PlutusTx.unstableMakeIsData ''DatumSwap

{-# INLINABLE mkValidator #-}
mkValidator :: DatumSwap -> () -> ScriptContext -> Bool
mkValidator ds _ ctx = traceIfFalse "Hey! You have to pay the owner!" outputToBeneficiary
                    && traceIfFalse "Double spending attempt!"        hasOneOutput
    where
        txInfo :: TxInfo
        txInfo = scriptContextTxInfo ctx

        outputToBeneficiary :: Bool
        outputToBeneficiary = 
          valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)

        hasOneOutput :: Bool
        hasOneOutput = length (txInfoInputs txInfo) == 1


{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator


validator :: Validator
validator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])
